# ðŸ“Œ Step 1: Import Required Libraries
import sys
import subprocess
import os
os.environ["TF_ENABLE_ONEDNN_OPTS"] = "0"

# Ensure TensorFlow 2.6.0+ is installed for Python 3.9 compatibility
try:
    import tensorflow as tf
    from packaging import version
    if version.parse(tf.__version__) < version.parse("2.6.0"):
        raise ImportError("TensorFlow version < 2.6.0")
except (ImportError, ModuleNotFoundError):
    print("Installing TensorFlow 2.6.0 for Python 3.9 compatibility...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "tensorflow==2.6.0"])
    import tensorflow as tf

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
from sklearn.preprocessing import StandardScaler
import warnings
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
warnings.filterwarnings('ignore')

# ðŸ“Œ Step 2: Load the Dataset
df = pd.read_csv("T1.csv")

# ðŸ“Œ Step 3: Preprocess the Data
df['DateTime'] = pd.to_datetime(df['Date/Time'])
df = df.drop(columns=['Date/Time'])
df = df.sort_values('DateTime')
df = df.set_index('DateTime')

# ðŸ“Œ Step 4: Feature Engineering
## Extract time-based features
df['hour'] = df.index.hour
df['day'] = df.index.day
df['month'] = df.index.month

## Create lag features for Wind Speed and Power Output
for lag in [1, 2, 3, 6]:
    df[f'wind_speed_lag_{lag}'] = df['Wind Speed (m/s)'].shift(lag)
    df[f'power_lag_{lag}'] = df['LV ActivePower (kW)'].shift(lag)

## Rolling mean features
df['wind_speed_roll_mean'] = df['Wind Speed (m/s)'].rolling(window=3).mean()
df['power_roll_mean'] = df['LV ActivePower (kW)'].rolling(window=3).mean()

## Drop NaNs generated by shift/rolling
df = df.dropna()

# ðŸ“Œ Step 5: Define Multi-Step Target
df['target_1'] = df['LV ActivePower (kW)'].shift(-1)
df['target_2'] = df['LV ActivePower (kW)'].shift(-2)
df['target_3'] = df['LV ActivePower (kW)'].shift(-3)
df = df.dropna()

features = df.drop(columns=['target_1', 'target_2', 'target_3'])
targets = df[['target_1', 'target_2', 'target_3']]

# ðŸ“Œ Step 6: Scaling Features
scaler = StandardScaler()
features_scaled = scaler.fit_transform(features)

# ðŸ“Œ Step 7: Train-Test Split (LSTM needs reshaped input)
X_train, X_test, y_train, y_test = train_test_split(features_scaled, targets.values, test_size=0.2, shuffle=False)

X_train_lstm = X_train.reshape((X_train.shape[0], 1, X_train.shape[1]))
X_test_lstm = X_test.reshape((X_test.shape[0], 1, X_test.shape[1]))

# ðŸ“Œ Step 8: LSTM Model for Multi-Step Forecasting
model_lstm = Sequential()
model_lstm.add(LSTM(50, activation='relu', input_shape=(1, X_train.shape[1])))
model_lstm.add(Dense(3))
model_lstm.compile(optimizer='adam', loss='mse')
model_lstm.fit(X_train_lstm, y_train, epochs=10, batch_size=32, verbose=1)

# ðŸ“Œ Step 9: Evaluate LSTM Model
y_pred_lstm = model_lstm.predict(X_test_lstm)
rmse_lstm = np.sqrt(mean_squared_error(y_test, y_pred_lstm))
print(f"LSTM RMSE (3-step forecast): {rmse_lstm:.2f} kW")

# ðŸ“Œ Step 10: Plot Predictions
plt.figure(figsize=(15,5))
plt.plot(y_test[:100, 0], label='Actual t+1')
plt.plot(y_pred_lstm[:100, 0], label='Predicted t+1', linestyle='--')
plt.title('Multi-step Forecasting - Time Step +1')
plt.legend()
plt.show()

plt.figure(figsize=(15,5))
plt.plot(y_test[:100, 2], label='Actual t+3')
plt.plot(y_pred_lstm[:100, 2], label='Predicted t+3', linestyle='--')
plt.title('Multi-step Forecasting - Time Step +3')
plt.legend()
plt.show()

# ðŸ“Œ Final Step: Detailed RMSE per forecast horizon
for i, step in enumerate(['t+1', 't+2', 't+3']):
    rmse = np.sqrt(mean_squared_error(y_test[:, i], y_pred_lstm[:, i]))
    print(f"RMSE for forecast horizon {step}: {rmse:.2f} kW")

# ðŸ“Œ Save the trained model (optional but recommended)
model_lstm.save("wind_power_lstm_model.h5")
print("Trained LSTM model saved as 'wind_power_lstm_model.h5'")

# ðŸ“Œ Next Steps Suggestions:
print("\nNext steps to enhance the model and align with DS3/DASSA:")
print("- Experiment with longer lookback windows (use sequences > 1 timestep for LSTM input)")
print("- Tune hyperparameters: number of LSTM units, layers, epochs, batch size")
print("- Incorporate additional features (weather forecasts, grid status indicators)")
print("- Develop a dashboard (e.g., Streamlit) for visualization and real-time forecasts")
print("- Collaborate with the DS3/Celtic team to validate with internal data")

# Optional: Plot residuals for the first forecast horizon to visually assess errors
plt.figure(figsize=(12,5))
residuals = y_test[:,0] - y_pred_lstm[:,0]
plt.plot(residuals[:200])
plt.title("Residuals for 1-step ahead forecast (first 200 samples)")
plt.ylabel("Error (kW)")
plt.show()
